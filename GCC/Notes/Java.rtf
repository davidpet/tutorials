{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf810
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww28600\viewh15100\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 To expedite learning, I will compare things to C# when applicable below\
\
Basic Terms\
	JVM			Java Virtual Machine (like CLR in .NET)\
	JRE			Java Runtime Environment (the JVM that runs on end-user machines, generally installed by an installer like Oracle)\
	JDK			What developers install -> has the JRE within it and also symbols and other things to make developing Java easier\
				NOTE: Without the JDK, you can\'92t see parameter names or documentation for built-in Java library stuff (or even 3rd party libs)\
	JNI			Library for native interfaces to Java code (C++ and Java talking)\
\
	JAR			Archive file containing classes (can act as class library or executable when run by java)\
	.class			File containing bytecode for a single Java class (loadable and runnable by java)\
	.java			Source code file for a Java class\
\
Java Versions/Editions/Distributions\
	OpenJDK		Open-source free version of Java based on Java 7 w/ Java 8 features being added (probably the cool stuff like lambdas)\
	Sun Java		The original (now bought by Oracle)\
	Oracle Java		The official one which is ending up to be a lot of trouble for people due to them suing everyone\
\
	Java ME		Micro Edition (for limited resource devices)\
	Java SE		The normal one (workstations)\
	Java EE		Enterprise (large-scale distributed environments)\
	Android		Uses subset of SE compatible with Java 7 & some Java 8 features (Android has its own JVM and bytecode)\
				The cool stuff like lambadas are supported, but if you need all of Java 8 there is a compiler called Jack that you can set Android Studio to use\
	\
	Java SE 6		Version from 2006\
	Java SE 7		Version from 2011\
	Java SE 8		Version from 2014 (latest and only officially supported one)\
\
Attributes\
	Similar to C# but use @ instead of []\
	Actually called Annotations in Java (static metadata on types and code)\
	\
	@FunctionalInterface		Used for declaring an interface that acts like a delegate in C#\
	@Override				For overriding virtual methods\
	@Deprecated\
	@SuppressWarnings\
\
	Custom Annotations can be defined using a funky syntax\
\
Classes\
	Per File		Each .java file has to have only one top-level class (although it can have nested classes)\
				NOTE: nested classes will have their own .class file when built\
	Base Object		All classes inherit from Object\
	Inheritence		Single possible base plus interfaces (like C#) (but syntax is comparatively non-uniform)\
				
\i public class MyClass extends MyBaseClass implements MyInterface1, MyInterface2 \{\}
\i0 \
				
\i public interface MyInterface extends MyInterface1, MyInterface2 \{\}
\i0 \
				NOTE: you can\'92t do the crazy explicit interface stuff you can in C# (it is simple like in C++)\
	Protection Level	\'91package\'92 is equivalent of C# \'91internal\'92 (roughly) ((it is also the default))\
	Nested		Java distinguishes between instance and static nested classes (have to be in instance to instantiate if you don\'92t make it static)\
\
	Virtual			All methods are virtual (instead of keyword like C# and C++) unless marked as final (like sealed in C#)\
	Abstract		same as C# (can have abstract classes and methods)\
	Sealed		Sealed keyword in C# = \'91final\'92 in Java\
	Static			Works same way except you can\'92t declare a class as static (though it can have only static members if want)\
\
	Anonymous		can use \'91new\'92 keyword with an interface and then in \{\} you give a definition for the elements of the interface (like an inline class)\
				This will return you an object that implements the interface, but you can\'92t just make up members like in C#\
\
	Static Constructors	Unlike in C#, you do not use the name of the class in a static constructor (unlike normal constructor), just the word static and the \{\} (with no access level)\
				It is called first time class is used\
	Constructor Blocks	Unique to Java, can have blocks with no name inside class and that code automatically goes into all constructors (common constructor code)\
	Delegating c\'92tors	use this() to call another constructor, but it has to be the FIRST line in the constructor\
	Base c\'92tors		use super() to call base constructor (has to be the FIRST line in the c\'92tor)\
	Destructors		finalize() method (no ~ syntax)\
\
	Static Members	Can access through instance (unlike C#, but like C++)\
\
	this			Works same way as in C#\
	super			Works the same way as base in C# (can call base class)\
\
	Default Methods				Interfaces can have methods declared as \'93default\'94 (no public needed) that provide default implementations (making it act like a base class kind of)\
	Static Interface Methods			A method in an interface can be declared static (no public needed) and an implementation given\
\
	Overriding Virtual Methods			@Override attribute on the method\
\
Methods\
	Variadic		
\i void myfunc(String\'85 args)
\i0 \
				Gives you an array (you can also pass an array in instead)\
\
Synchronized\
	Methods			Methods can be declared as \'91synchronized\'92 so that a mutex on the class instance (or class itself if static) is obtained before entering\
	Objects			You can obtain a mutext on an object with synchronized(o) \{\}\
\
Enums\
	public enum MyEnum \{VAL0, VAL1\}		Normal case is like C# and C++\
	public enum MyEnum \{VAL0(0)\}			Values specified with () instead of =\
	\
	Declaring Values					Use enum name with dot like C# (but in switches you don\'92t have to)\
	Iterating Values					Can iterate MyEnum.values() in a for loop\
	Crazy Stuff						Can implement interfaces, have methods, constructors, and fields (unlike C#)\
\
	Type							Implicitly extend java.lang.Enum (and they are classes)\
\
Packages\
	
\i package com.jarofgoblins.tools;
\i0 			Must define package that class goes into at top of the .java file (like C# namespace)\
								NOTE: in Java, the package components must describe subfolders in the path to the src file\
	
\i import com.jarofgoblins.*;
\i0 				Can import packages or specific classes from packages in other .java files to use in your code\
								NOTE: just like C# using, you can ommit this and use the fully-qualified name in code\
	java.lang						Default package that is always imported implicitly (contains the basic types)\
\
Libraries\
	Parameter Names			Unlike C#, parameter names are not part of method prototypes and are not generally included in .class and .jar files\
						To see the built-in stuff, you need the JDK.  To see 3rd party stuff, you need to point the .jar/.class references to source code.\
\
Entry Point\
	
\i public static void main(String[] args)
\i0 			Provide this to make a class runnable as a standalone program (eg. test code, or the entry point of the program)\
\
Printing\
	
\i System.out.println(\'93hi\'94);
\i0 		Prints text followed by newline to the console\
	
\i System.out.printf(\'93%s\'94, \'93hi\'94);
\i0 	Formatted Printing\
\
Casting\
	
\i DerivedClass d = (DerivedClass)b;
\i0 			If it works, great.  If it doesn\'92t, you get 
\i ClassCastException\

\i0 	\
Reflection\
	
\i b instanceof DerivedClass	
\i0 				Boolean test of whether b is polymorphically castable to DerivedClass\
	
\i b.getClass() == DerivedClass.class
\i0 			Alternative way to do the same thing as 
\i instanceof
\i0 \
\
	
\i o.getClass()
\i0 							Get the type of the object at runtime\
	
\i Class.class
\i0 							Get the type of a class at compile time (comparable to runtime types from 
\i getClass()
\i0 )\
\
Basic Types\
	Object								The base object type for all objects\
	String\
	byte\
	boolean\
	char								unicode character\
	short								16-bit signed integer\
	int								32-bit signed integer\
	long								64-bit signed integer\
	float\
	double\
\
	Arrays								just like C# (and even support \{\} syntax) (.length variable for the length)\
\
	NOTE: the lowercase ones are primitives and basically act like value types\
	NOTE: no unsigned numbers\
\
	To get things like maximum, minimum, etc. look at static methods in the wrapper classes (see Nullable Types section)\
\
	Default Initialization						local = have to initialize, class instance = normal defaults (like 0), static = same as class instance\
	Member Variable Initialization				can be done in declaration or constructor like in C#\
\
Nullable Types\
	Wrapper classes like Integer, Boolean, etc. are in java.lang to wrap primitives as class instances so that they can be null\
	These wrappers also have static methods like MAX_VALUE and MIN_VALUE\
\
Declarations\
	Constants							\'91final\'92 keyword (like \'91readonly\'92 in C# or \'91const\'92 in C++)\
									NOTE: final references can point to objects that are still modifiable\
	Statics							have to be on class, not inline (but can be final to make constants)\
\
Statements\
	Range-fors							Exactly like the new C++ version of range-fors but no extra modifiers like &\
	Typical C-like stuff						All this stuff works (eg. if, do/while, etc.)\
	Switches							Work with primitives and strings, have same behavior as C++ (break and default)\
\
Functional Programming\
	Delegates							Functional Interfaces (define an interface with a single method and use the @FunctionalInterface attribute on the interface or method)\
									The interface becomes the delegate type which can be assigned things like lambdas\
									Have to call the method as a member of the object that is passed in as the interface\
									NOTE: I also saw an example that did not use @FunctionalInterface but made the method \'91default\'92 without a body\
	Lambdas							Assignable to functional interfaces (like your\'92e providing a class that implements the interface)\
									Uses -> instead of => like C#\
									
\i (int x, int y) -> x + y    //typical case
\i0 \
									
\i (int x, int y) -> \{ return x + y; \} 
\i0    //multiline case (explicit return needed)\
									
\i (x, y) -> x + y
\i0 	    //can ommit parameter types if ommit ALL of them\
									
\i x -> x * x
\i0 	//can ommit () only if one parameter [even 0 requires ()]\
									
\i x -> System.out.println(\'93hi\'94); 
\i0   //same syntax even if not returning a value\
	Method References						mylambda = MyClass::method;   //as long as the method fits the interface (note using :: instead of .)\
									Allowed to do for instances methods as well as static (like C#)\
	Closures							Any variable used in a lambda that is defined outside of it is captured, but the compiler requires it to be either \'91final\'92 or \'91effectively final\'92\
									Effectively final means it is treated by code as if it\'92s final (so if other code changes it you probably need a copy)\
									This seems to only allow capturing by value, but you can actually capture a final reference to an object, and the object will be changeable\
									Thus, with a little extra work you can do the normal closure stuff\
\
	Declarative							Collection<E> has a stream() method to get a Stream<E>\
									Also parallelStream() method to get one that will use multithreading\
									Stream<T> is a lazy sequence with functional methods\
									allMatch, anyMatch (w/ predicates)\
									distinct, empty, filter, findFirst, findAny, map, max, min, reduce, sorted\
									forEach to perform an action on each element\
									Chain together calls just like LINQ and then convert to array at the end with toArray()\
									Can also use .collect() method which takes a collector (returned by static methods of Stream<T>.Collectors) to transform the sequence into something\
									Collectors.toList(), Collectors.groupBy(), etc.\
\
Disposable Pattern\
	AutoCloseable						Interface which defines a single void method close() that takes no parameters (similar to IDisposable in C#)\
	try (AutoClosable c = new Something()) \{\}		Equivalent of \'91using\'92 block in C#\
	Multiple objects						Just separate with comma in the try statement\
	Exceptions							Since this is a try block, you can presumably catch exceptions here (???)\
									Either way, you can assume if an exception is thrown, the object is closed properly (like in C#)\
Cloning\
	Cloneable interface						Defines clone() method that returns object\
	Object								has clone() method that throws exception if class doesn\'92t implement Cloneable interface\
\
Exceptions\
	java.lang.Throwable						Interface that all exceptions must implement in order to be throwable\
	java.lang.Exception						Base exception provided by the language (implements Throwable)\
	java.lang.RuntimeException				Special class of exceptions like divide by zero that you are not expected to declare in methods\
\
	Throwing							
\i throw new MyException();
\i0 \
	Methods							A method must declare all its exceptions except the ones that inherit from RuntimeException (causes propagation to methods that call your method)\
									
\i public void mymethod() throws MyException1, MyException2 \{\}
\i0 \
	Catching							try/catch/finally like in C# (empty one is just catch \{\})\
	Rethrowing							
\i throw ex;
\i0 \
\
Generics\
	Methods							Type args go in <> before the method\'92s return type (not after the method name like C#)\
									Type inference allowed just like in other languages\
	Allowed Types						Type args have to be reference types, not primitives (String is fine but int is not) [remember numeric types have wrappers]\
	Restricting Types						Can specify \'91extends\'92 or \'91implements\'92 (and even use the type param in it nested) to restrict what the type can be for a type arg (this will let you use the interface)\
	Type Wildcards						For allowing some fuzziness in types when you specify the type of a generic in code (actual usage) [represents multiple types, not one type of mixed type]\
									List<?> is a list of anything that derives from Object (and reading the list will give you an Object) [can\'92t add to collection because not type safe]\
									List<? extends Number> is a list of anything that derives from Number (and thus you can use members of Number and the list will return Number)\
									List<? super Number> is a list of anything that is Number or one of its bases (returns Object but can add as Number)\
	Classes							Types go after classname like in C# (otherwise use same rules as above)\
	Interfaces							Same as classes\
\
	Covariance/Contravariance				Implemented via type wildcards\
									PECS (Producer Extends, Consumer Super) [from collection\'92s point of view -> producer = collection returns values, consumer = collection gets values]\
	Diamond Operator						Use empty <> instead of the full type list on the right-hand side of an assignment (because types already on left of assignment)\
									Not sure if works for other contexts and if works when thing on left is not perfect match (but has same type list)\
	Type Erasure							Compiler checks type safety at complie-time and then compiles the type as non-generic (eg. simply List which deals with Object)\
									As a result, unlike in C#, you cannot determine the type of the generic at runtime\
									You also cannot instantiate an instance of the type\
									Another consequence is that static members of the generic are shared among all the instances with any type args, and type args cannot be used in the statics\
	\
	NOTE: I\'92ve seen examples where type is ommited entirely from left side without even using <> (not sure if that means the type is object?)\
\
java.lang.Object\
	equals()							Override to provide value comparison\
	hashCode()							Generally want to implement if you implement equals() [also needed for containers]\
\
	clone()							Clones object only if it implements ICloneable (otherwise throws)\
	\
	finalize()							Destructor\
\
	getClass()							Gets the type of the object at runtime (as Class<?>)\
	toString()							Get string representation\
\
	various wait() and notify() calls				For synchronization special stuff\
\
Collections\
	java.util							Tends to be where collections come from\
\
	Arrays								Class with static methods for doing things like searching and sorting arrays\
									asList() returns List<T> for an array (bridges arrays and collections) [or variadic args]\
\
	Iterable<T>							Interface that supports the range-for statement (single method that returns iterator)\
	Collection<E>						Interface for modifiable collection of objects (can add, addAll [another collection], size(), toArray(), contains, containsAll, isEmpty, etc.) [NOTE: addAll has to be right element type but can be any collection]\
									Also has a stream() method to return a Stream<E> which is the gateway to declarative LINQ-like stuff\
	List<E>							Interface for ordered list (adds things like subList, indexOf)\
	\
	ArrayList<E>							Resizable implementation of List<E> (constructor can take collection)\
									Because Java does not have operator overloading, you must use get() and set() to access the items (not subscript operator)\
	Vector<E>							Like ArrayList, but thread-safe (synchronized)\
\
	Map<K, V>							Interface for key-value maps (dictionaries)\
	HashMap<K, V>						Concrete implementation of map (NOTE: there was a dictionary class which is now obsolete)\
	Set<E>							Interface for sets of unique values\
	HashSet<E>							Concrete implementation of Set<E> based on hash\
									NOTE: remember that it\'92s all methods (no [] operator)\
\
File I/O\
	java.io								Package containing all the file I/O stuff\
	\
	FileInputStream/FileOutputStream			Byte streams (construct with filename, call read() to get a char at a time until it returns -1) [call close() at the end]\
	FileReader/FileWriter					Unicode character streams (exactly same behavior as byte streams but the int is castable to char)\
	\
	System.out, System.in, System.err			Standard streams (available all the time statically)\
									System.in can be read with InputStreamReader(System.in)\
\
	Creating directory						Instantiate File with the path and then call mkdir() or mkdirs() [the 2nd one creates appropriate parents]\
	List Files							Instantiate File with the path and then call list() to get an array of strings\
\
	BufferedReader						Lets you read character by character or line by line\
\
Serialization\
	Library Objects						To know if a type is serializable, see if it implements java.io.Serializable\
	Custom Classes						To make a class serializable, implement the Serializable interface (don\'92t even have to implement anything to implement the interface)\
									All fields of the class should also be serializable.  Those that aren\'92t should be marked as \'91transient\'92 (declaration keyword) so they aren\'92t included\
	.ser								Convention for file extension of a serialized java object\
	Serializing							Create FileOutputStream, then create ObjectOutputStream with it, then call writeObject() and then close() both\
	Deserializing							Same in reverse (FileInputStream, ObjectInputStream, and readObject)\
\
	NOTE: it is possible to provide more customized serialization by providing writeObject() and readObject() in the class [can be private, not part of interface]\
\
Regular Expressions\
	java.util.regex						Package containing regex classes\
\
Threading\
	java.lang.Runnable						Interface for execution by thread without extending thread class\
									Can assign a lamdba (void -> void) to a variable of type Runnable (which can then be used to construct and start a Thread)\
	java.lang.Thread						Can be used directly or extended to create a separate thread of execution\
									Implement run() method to provide the code that executes when the thread runs (if you extended it)\
									Call start() to start the thread\
									Various typical methods like join() and static sleep() stuff\
\
Missing Features\
	Structs/Value Types						You\'92d have to create a class and copy it to get this kind of behavior\
	Ref and Out Parameters					You\'92d have to pass in a class that holds the thing you want to change\
	Default Parameters						Have to manually overload\
	compiler-time Type Inference				No auto or var available (always have to specify type)\
	Typedef							Out of Luck\
	Unsigned Numbers						Not here\
	Macros							Nope!\
	Static Classes						You can simulate by declaring as abstract and final, or just ignore not having this and make static methods anyway\
	Partial Classes\
	Anonymous Classes with Arbitrary Members		You can return anonymous classes that implement interfaces though\
	Operator Overloading					Ouch!\
	Properties							No computed or stored properties, have to use setters/getters and member variables\
	Events							There is something like delegates (functional interfaces) but nothing like events explicitly (though you can do something like it)\
	Collection Initializers					can\'92t do \{\} like in C# and C++ (except for arrays)\
	Coalescing and \'91as\'92 operator				\
	Passing in parameters by name\
	Extension Methods\
	Specifying Inline Method\
}